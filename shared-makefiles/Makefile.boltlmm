## Lightning Auriga, 22 May 2020
## workflow for BOLT-LMM analyses

GENOTYPE_DIR := $(CLEANED_CHIP_OUTPUT_DIR)
IMPUTED_DIR := $(BGEN_OUTPUT_DIR)

RESULTS_DIR := $(RESULT_OUTPUT_DIR)
CONFIG_DIR := $(CONFIG_INPUT_DIR)
ANALYSIS_CONFIGS := $(shell ls $(CONFIG_DIR)/*)
## empirical approximate minimum subject count, specific to BOLTLMM
MINIMUM_VALID_SUBJECT_COUNT := $(BOLTLMM_MINIMUM_VALID_SUBJECT_COUNT)
## construct analysis targets for all config entries that request BOLT
ANALYSIS_RESULTS_BOLTLMM := $(addprefix $(RESULTS_DIR)/,$(foreach config,$(ANALYSIS_CONFIGS),$(shell $(SHARED_SOURCE)/construct_output_filenames.bash $(config) boltlmm $(MINIMUM_VALID_SUBJECT_COUNT) $(IMPUTED_DIR))))

.SECONDEXPANSION:
.SECONDARY:
.DELETE_ON_ERROR:
.PHONY: all $(ANALYSIS_RESULTS_BOLTLMM)
all: $(ANALYSIS_RESULTS_BOLTLMM) | $(sort $(dir $(ANALYSIS_RESULTS_BOLTLMM)))

$(ANALYSIS_RESULTS_BOLTLMM): $$(addsuffix .tsv.gz,$$@) | $$(dir $$@)


define check_model_matrix
"$(strip $(shell wc -l $(1) | awk '{print $$1}'))" -gt "$(MINIMUM_VALID_SUBJECT_COUNT)"
endef

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.tsv.gz
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.tsv
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.model_matrix.success
## Notes: gzip the genome-wide BOLTLMM results.
## the model matrix is only required here to enforce a preflight sample size check.
%.tsv.gz: %.tsv %.model_matrix.success
	if [[ $(call check_model_matrix,$(subst .success,,$(lastword $^))) ]] ; then \
	gzip -c $< > $@ ; \
	fi

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.tsv
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.boltlmm.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.model_matrix.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: combine results from per-chromosome BOLTLMM runs into a single genome-wide file, suitable for meta-analysis.
## the model matrix is only required here to enforce a preflight sample size check.
$(addsuffix .tsv,$(ANALYSIS_RESULTS_BOLTLMM)): $$(patsubst %,$$(subst .boltlmm.tsv,,$$@).chr%.boltlmm.success,$$(CHRS)) $$(subst .boltlmm.tsv,,$$@).boltlmm.model_matrix.success | $$(dir $$@)
	if [[ $(call check_model_matrix,$(subst .success,,$(lastword $^))) ]] ; then \
	cat $(filter-out %.model_matrix.success,$(subst .boltlmm.success,.boltlmm,$^)) | awk '! /SNP\tCHR\tBP/ && ! ($$10 ~ /nan/)' | sed 's/ /\t/g' | awk 'NR == 1 {print "CHR\tPOS\tSNP\tTested_Allele\tOther_Allele\tFreq_Tested_Allele_in_TOPMed\tBETA\tSE\tP\tN"} ; {print $$2"\t"$$3"\t"$$1"\t"$$5"\t"$$6"\tNA\t"$$9"\t"$$10"\t"$$11"\tNA"}' > $@ ; \
	fi

## phony clean target to eliminate all BOLT analysis directories
.PHONY: dangerous-clean
dangerous-clean:
	rm -Rf $(sort $(dir $(ANALYSIS_RESULTS_BOLTLMM)))


## utility function to grab {CHIP} out of results/{PHENOTYPE}/{ANCESTYR}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.{whatever}
define extract_chip =
$(firstword $(subst _,$(2),$(lastword $(subst ., ,$(word 1,$(subst .chr, ,$(subst GSA_,GSA/,$(1))))))))
endef

## utility function to grab {ANCESTRY} out of results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.{whatever}
define extract_ancestry =
$(word 3,$(subst /, ,$(1)))
endef

## needs: bgen file (just bfile for now)
##        phenotype file (unknown format)
##        qcovar file (unknown format)
##        ldScores file (from ldsc, based on 1000 Genomes superpops for the moment)
##        covar file (unknown format)
## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.boltlmm.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38-resorted-nochr0.bed.success
##    input:  {BGEN-INPUT}/{CHIP}/{ANCESTRY}/chr{CHR}-filtered.bgen
##    input:  {BGEN-INPUT}/{CHIP}/{ANCESTRY}/chr{CHR}-filtered-noNAs.sample
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.phenotype
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.covariates
##    input:  {LDSCORE_FILES}/LDSCORE.1000G_{SUPERCONTINENT}l2.ldscore-reformatted.gz
## Notes: run primary BOLT-LMM analysis by chromosome. requires genotype data directly aligned with LDSCORE information,
## so based on the particularities of the PLCO analysis, the chip data need to be lifted to GRCh38 first. bgen files
## must be v1.2 based on current BOLT (2.3.4) requirements for fast processing. Model matrix is used for on the fly minimum
## sample size enforcement.
$(foreach result,$(ANALYSIS_RESULTS_BOLTLMM),$(patsubst %,$(subst .boltlmm,,$(result)).chr%.boltlmm.success,$(CHRS))): $$(word 1,$$(subst .chr, ,$$@)).bolt-chip.GRCh38-resorted-nochr0.bed.success $$(IMPUTED_DIR)/$$(call extract_chip,$$@)/$$(call extract_ancestry,$$@)/$$(lastword $$(subst ., ,$$(subst .boltlmm.success,,$$@)))-filtered.bgen $$(IMPUTED_DIR)/$$(call extract_chip,$$@)/$$(call extract_ancestry,$$@)/$$(lastword $$(subst ., ,$$(subst .boltlmm.success,,$$@)))-filtered-noNAs.sample $$(word 1,$$(subst .chr, ,$$@)).boltlmm.phenotype $$(word 1,$$(subst .chr, ,$$@)).boltlmm.covariates $$(shell $(SHARED_SOURCE)/resolve_bolt_ldscore.bash $$(call extract_ancestry,$$@)) $$(word 1,$$(subst .chr, ,$$@)).boltlmm.model_matrix.success
	if [[ $(call check_model_matrix,$(subst .success,,$(lastword $^))) ]] ; then \
	$(call qsub_handler,$(subst .success,,$@),$(BOLTLMM_EXECUTABLE) --bfile $(subst .bed.success,,$(word 1,$^)) --bgenFile $(word 2,$^) --sampleFile $(word 3,$^) --lmm --LDscoresFile=$(subst .gz,-reformatted.gz,$(word 6,$^)) --statsFile=$(subst .boltlmm.success,.chip_results.boltlmm,$@) --statsFileBgenSnps=$(subst .success,,$@) --phenoFile $(word 4,$^) --phenoCol $(shell head -1 $(word 4,$^) | cut -f 3) --covarFile $(word 5,$^) --qCovarCol $(shell head -1 $(word 5,$^) | cut -f 1-2 --complement | sed 's/\t/ --qCovarCol /g') --LDscoresMatchBp --geneticMapFile /home/palmercd/Development/BOLT-LMM_v2.3.4/tables/genetic_map_hg19_withX.txt.gz > $(subst .success,.log,$@) 2>&1) ; \
	else \
	touch $@ ; \
	fi

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38-resorted-nochr0.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38-resorted.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip-GRCh38-resorted-chr0.exclude
## Notes: remove "0" chromosome annotations for compatibility with BOLT
%.bolt-chip.GRCh38-resorted-nochr0.bed.success: %.bolt-chip.GRCh38-resorted.bed.success %.bolt-chip.GRCh38-resorted.chr0.exclude
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --exclude $(word 2,$^) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38-resorted.chr0.exclude
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38-resorted.bed.success (really bim)
## Notes: get a plink-format exclude file for variants with unlocalized chromosome
%.bolt-chip.GRCh38-resorted.chr0.exclude: %.bolt-chip.GRCh38-resorted.bed.success
	awk '$$1 == 0 {print $$2}' $(subst .bed.success,.bim,$<) > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38-resorted.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38.bed
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip-GRCh38.bim
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38.fam
## Notes: liftover likely breaks order of variants in the genome; quickest solution is just to reload and rewrite everything with plink.
%.bolt-chip.GRCh38-resorted.bed.success: %.bolt-chip.GRCh38.bed %.bolt-chip.GRCh38.bim %.bolt-chip.GRCh38.fam
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bed $< --bim $(word 2,$^) --fam $(word 3,$^) --allow-extra-chr 0 --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.samples
##    input:  {IMPUTED_DATA}/{CHIP}/{ANCESTRY}/chr22-filtered-noNAs.sample
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: final subject list for actual imputed data. used for compatibility with SAIGE shared code. some applications
## to ensure synchronization between chip and imputed data are no longer necessary in final PLCO dataset
%.boltlmm.samples: $$(IMPUTED_DIR)/$$(subst GSA_,GSA/$$(word 2,$$(subst ., ,$$(notdir $$@))))/$$(lastword $$(subst /, ,$$(subst BOLTLMM,,$$(dir $$@))))/chr22-filtered-noNAs.sample | $$(dir $$@)
	awk 'NR > 2 {print $$1"_"$$1}' $< > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38.bed
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.lift-failures-excluded.bed.success
## Notes: this was a late addition to the pipeline, as it was originally tested on chip data in hg19 but then deployed on
## imputed data in GRCh38. so it's just a hack liftover intermediate step.
%.bolt-chip.GRCh38.bed: %.bolt-chip.lift-failures-excluded.bed.success
	cp $(subst .success,,$<) $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38.bim
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.lift-failures-excluded.bed.success (really bim)
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.liftover-output
## Notes: this was a late addition to the pipeline, as it was originally tested on chip data in hg19 but then deployed on
## imputed data in GRCh38. hack liftover data by taking liftover output and manually swapping in new position data over old.
%.bolt-chip.GRCh38.bim: %.bolt-chip.lift-failures-excluded.bed.success %.bolt-chip.liftover-output
	paste $(word 2,$^) $(subst .bed.success,.bim,$<) | sed 's/chr// ; s/:/\t/ ; s/-/\t/' | awk '{print $$1"\t"$$5"\t"$$6"\t"$$2"\t"$$8"\t"$$9}' > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.GRCh38.fam
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.lift-failures-excluded.bed.success (really fam)
## Notes: this was a late addition to the pipeline, as it was originally tested on chip data in hg19 but then deployed on
## imputed data in GRCh38. so it's just a hack liftover intermediate step.
%.bolt-chip.GRCh38.fam: %.bolt-chip.lift-failures-excluded.bed.success
	cp $(subst .bed.success,.fam,$<) $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.lift-failures-excluded.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.liftover.exclude
## Notes: first step to updating plink file with GRCh38 lifted positions: remove variants that failed lift, in order
%.bolt-chip.lift-failures-excluded.bed.success: %.bolt-chip.bed.success %.bolt-chip.liftover.exclude
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --exclude $(word 2,$^) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.liftover.exclude
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.liftover-output (really liftover-failure)
## Notes: convert failed lifts into a plink-format exclude file
%.bolt-chip.liftover.exclude: %.bolt-chip.liftover-output
	awk '! /^#/' $(subst liftover-output,liftover-failure,$<) | sed 's/chr// ; s/-/\t/' | awk '{print $$1}' > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.liftover-output
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.liftover-input
## Notes: run liftover, chips are in hg19 and imputed data are in GRCh38
%.bolt-chip.liftover-output: %.bolt-chip.liftover-input
	$(LIFTOVER_EXECUTABLE) -positions $< $(LIFTOVER_19_TO_38) $@ $(subst liftover-output,liftover-failure,$@)

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.liftover-input
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.bed.success
## Notes: 
%.bolt-chip.liftover-input: %.bolt-chip.bed.success
	awk '{print "chr"$$1":"$$4"-"$$4}' $(subst .bed.success,.bim,$<) > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.bolt-chip.bed.success
##    input:  {CLEANED_CHIPS_BY_ANCESTRY}/{ANCESTRY}/{CHIP}.nohet.autosomes.bed
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.samples.plink-format
##    input:  {CLEANED_CHIPS_BY_ANCESTRY}/{ANCESTRY}/{CHIP}.step2.pruning.prune.in
##    input:  {CLEANED_CHIPS_BY_ANCESTRY}/{ANCESTRY}/{CHIP}.step3.pruning.prune.out
## Notes: gets an ancestry-specific LD-pruned (more or less) dataset for BOLT heritability estimation.
%.bolt-chip.bed.success: ../cleaned-chips-by-ancestry/$$(call extract_ancestry,$$@)/$$(call extract_chip,$$(subst .bolt-chip.bed.success,,$$@)).nohet.autosomes.bed %.boltlmm.samples.plink-format ../cleaned-chips-by-ancestry/$$(call extract_ancestry,$$@)/$$(call extract_chip,$$(subst .bolt-chip.bed.success,,$$@)).step2.pruning.prune.in ../cleaned-chips-by-ancestry/$$(extract_ancestry,$$@)/$$(extract_chip,$$(subst .bolt-chip.bed.success,,$$@)).step3.pruning.prune.out
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed,,$<) --keep $(word 2,$^) --extract $(word 3,$^) --exclude $(word 4,$^) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.samples.plink-format
##    input:  results/{PHENTOYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.samples
## Notes: take single column subject ID list and duplicate it into two columns, for plink --keep convention.
%.boltlmm.samples.plink-format: %.boltlmm.samples
	awk '{print $$1}' $< | sed 's/_/\t/g' > $@

## utility function to just grab the name of a phenotype from config files with an analysis name {PHENOTYPE}.{CHIP}
define get_phenotype
$(shell $(SHARED_SOURCE)/construct_phenotype.bash $(firstword $(subst /, ,$(subst results/, ,$(1)))) $(CONFIG_DIR))
endef

## utility function to just grab comma-delimited covariates from config files with an analysis name {PHENOTYPE}.{CHIP}
define get_covariates
$(shell $(SHARED_SOURCE)/construct_covariates.bash $(firstword $(subst /, ,$(subst results/, ,$(1)))) $(CONFIG_DIR))
endef

## utility function to just grab comma-delimited covariates from a model matrix
define get_covariates_from_model_matrix
$(shell awk 'NR == 1' $(1) | cut -f 1-3 --complement | sed 's/ /,/g; s/\t/,/g')
endef

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.phenotype
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.model_matrix.success
## Notes: rips out just the FID/IID and phenotype, assuming phenotype is in column 3
%.boltlmm.phenotype: %.boltlmm.model_matrix.success
	cut -f 1-3 $(subst .success,,$<) > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.covariates
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.model_matrix.success
## Notes: this assumes the phenotype is in column 3 of the model matrix.
## also assumes preprocessing of categoricals into binary dummies and eliminates the correct use of ordinals
%.boltlmm.covariates: %.boltlmm.model_matrix.success
	cut -f 3 --complement $(subst .success,,$<) > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.model_matrix.success
##    input:  [TODO: figure out what brain addled nonsense this was supposed to be because it's nothing now]
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.boltlmm.samples
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: build a model matrix containing phenotype and covariate data for all relevant subjects. for truly esoteric reasons
## this is separately submitted to the cluster.
%.boltlmm.model_matrix.success: $$(shell $(SHARED_SOURCE)/get_config_filename.bash $$(firstword $$(subst /, ,$$(subst results/, ,$$@))) $$(CONFIG_DIR)) $$(subst .model_matrix.success,.samples,$$@) | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),Rscript $(SHARED_SOURCE)/construct_model_matrix.R $(PHENOTYPE_FILENAME) $(lastword $^) $(word 3,$(subst /, ,$@)) $(lastword $(subst ., ,$(subst .boltlmm.model_matrix.success,,$@))) $(call get_phenotype,$@) $(call get_covariates,$@) $(subst .success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: build the output directory tree if needed.
$(sort $(dir $(ANALYSIS_RESULTS_BOLTLMM))):
	mkdir -p $@
