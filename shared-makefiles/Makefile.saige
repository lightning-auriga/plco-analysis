## Lightning Auriga, 28 May 2020
## workflow for SAIGE analyses

include $(PROJECT_BASE_DIR)/Makefile.config

GENOTYPE_DIR := $(CLEANED_CHIP_OUTPUT_DIR)
IMPUTED_DIR := $(BGEN_OUTPUT_DIR)
RESULTS_DIR := $(RESULT_OUTPUT_DIR)
CONFIG_DIR := $(CONFIG_INPUT_DIR)
ANALYSIS_CONFIGS := $(shell ls $(CONFIG_DIR)/*config.yaml)
## empirical approximate minimum subject count (+1), specific to SAIGE
MINIMUM_VALID_SUBJECT_COUNT := $(SAIGE_MINIMUM_VALID_SUBJECT_COUNT)

ANALYSIS_RESULTS_SAIGE := $(addprefix $(RESULTS_DIR)/,$(foreach config,$(ANALYSIS_CONFIGS),$(shell $(SHARED_SOURCE)/construct_output_filenames.bash $(config) saige $(MINIMUM_VALID_SUBJECT_COUNT) $(IMPUTED_DIR) $(RESULTS_DIR) $(PHENOTYPE_FILENAME) $(SHARED_SOURCE)/extract_columns.bash .phenotype_dataset .frequency_mode .phenotype_selected .covariates_selected .transform .sex-specific .finalized $(if $(findstring B,$(firstword -$(MAKEFLAGS))),1,0) $(if $(findstring n,$(firstword -$(MAKEFLAGS))),1,0))))

.SECONDEXPANSION:
.SECONDARY:
.DELETE_ON_ERROR:
.PHONY: all $(ANALYSIS_RESULTS_SAIGE) secondary-clean
all: $(ANALYSIS_RESULTS_SAIGE)

$(ANALYSIS_RESULTS_SAIGE): $$(addsuffix .tsv.gz,$$@) | $$(dir $$@)

## get a saved config parameter setting from a tracking file
define get_tracked_parameter =
$(shell cat $(1))
endef

## model matrix handling for association pipelines
define check_model_matrix =
"$(strip $(shell wc -l $(1) | awk '{print $$1}'))" -gt "$(2)" ]] && [[ "$(strip $(shell awk 'NR > 1 && $$3 != 0 && $$3 != 1' $(1) | wc -l))" -gt "0" || "$(strip $(shell awk 'NR > 1 && $$3 == 1' $(1) | wc -l))" -gt "$(3)"
endef



## patterns:
##    output: results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.tsv.gz
##    input:  results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.tsv
##    input:  results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.model_matrix.success
##    input:  results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/
## Notes: compress combined saige output file.
## the model matrix is only required here to enforce a preflight sample size check.
%.tsv.gz: %.tsv %.model_matrix.success | $$(dir $$@)
	if [[ $(call check_model_matrix,$(subst .success,,$(lastword $^)),$(MINIMUM_VALID_SUBJECT_COUNT),$(MINIMUM_VALID_CASE_COUNT)) ]] ; then \
	gzip -c $< > $@ ; \
	fi


## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.tsv
##    input:  [frequency annotation software]
##            results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.nofreq.tsv
##            results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.frequency_mode
##            results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.model_matrix.success
##            results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: add frequency data to a results file
%.saige.tsv: $(ANNOTATE_FREQUENCY) %.saige.nofreq.tsv %.saige.frequency_mode %.saige.model_matrix.success | $$(dir $$@)
	$(eval SUBJECT_FREQUENCIES := $(call get_tracked_parameter,$(word 3,$^)))
	if [[ $(call check_model_matrix,$(subst .success,,$(lastword $^)),$(MINIMUM_VALID_SUBJECT_COUNT),$(MINIMUM_VALID_CASE_COUNT)) ]] ; then \
	$(if $(filter $(SUBJECT_MODE),$(SUBJECT_FREQUENCIES)),ln -fs $(word 2,$^) $@,$< $(word 2,$^) $(TOPMED_FREQUENCY_FILE) $(call resolve_ancestry,$@) $@) ; \
	fi



## patterns:
##    output: results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.nofreq.tsv
##    input:  results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.saige.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.frequency_mode
##    input:  results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/{PHENOTYPE}.saige.model_matrix.success
##    input:  results/{ANCESTRY}/{PHENOTYPE}/{METHOD}/
## Notes: combine results from each autosome into a single genome-wide result. note allele flip to conform to format
## frequency is set to NA at this step and requires a separate processing step
%.saige.nofreq.tsv: $$(patsubst %,$$(subst .saige.nofreq.tsv,,$$@).chr%.saige.success,$$(CHRS)) %.saige.frequency_mode %.saige.model_matrix.success | $$(dir $$@)
	$(eval SUBJECT_FREQUENCIES := $(call get_tracked_parameter,$(filter %.frequency_mode,$^)))
	if [[ $(call check_model_matrix,$(subst .success,,$(lastword $^)),$(MINIMUM_VALID_SUBJECT_COUNT),$(MINIMUM_VALID_CASE_COUNT)) ]] ; then \
	cat $(subst .success,.txt,$(filter-out %.model_matrix.success %.frequency_mode,$^)) | awk '! /CHR POS rsid/' | awk 'NR == 1 {print "CHR\tPOS\tSNP\tTested_Allele\tOther_Allele\tFreq_Tested_Allele_in_TOPMed\tBETA\tSE\tP\tN"} ; {print $$1"\t"$$2"\t"$$3"\t"$$5"\t"$$4"\t$(if $(filter $(SUBJECT_MODE),$(SUBJECT_FREQUENCIES)),"$$7",NA)\t"$$10"\t"$$11"\t"$$13"\t"$$9}' > $@ ; \
	fi


## utility function to grab {CHIP} out of results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.{whatever}
define extract_chip =
$(firstword $(subst _,$(2),$(lastword $(subst ., ,$(word 1,$(subst .chr, ,$(subst GSA_,GSA/,$(1))))))))
endef

## utility function to grab {ANCESTRY} out of results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.{whatever}
define extract_ancestry =
$(word 2,$(subst /, ,$(subst $(RESULTS_DIR),,$(1))))
endef


## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.chr{CHR}.saige.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.round1.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.model_matrix.success
##    input:  {BGEN-INPUT}/{CHIP}/{ANCESTRY}/chr{CHR}-filtered.bgen
##    input:  {BGEN-INPUT}/{CHIP}/{ANCESTRY}/chr{CHR}-filtered.bgen.bgi
##    input:  {BGEN-INPUT}/{CHIP}/{ANCESTRY}/chr{CHR}-filtered-noNAs.sample
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.samples
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: run second round of SAIGE analysis, by autosome, using output of initial inflation estimation (LD-pruned) genome wide.
## but only run if the effective sample size is greater than some heuristic minimum.
$(foreach result,$(ANALYSIS_RESULTS_SAIGE),$(patsubst %,$(subst .saige,,$(result)).chr%.saige.success,$(CHRS))): $$(word 1,$$(subst .chr, ,$$@)).saige.round1.success $$(word 1,$$(subst .chr, ,$$@)).saige.model_matrix.success $$(IMPUTED_DIR)/$$(call extract_chip,$$@,/)/$$(call extract_ancestry,$$@)/$$(word 3,$$(subst ., ,$$(notdir $$@)))-filtered.bgen $$(IMPUTED_DIR)/$$(call extract_chip,$$@,/)/$$(call extract_ancestry,$$@)/$$(word 3,$$(subst ., ,$$(notdir $$@)))-filtered.bgen.bgi $$(word 1,$$(subst .chr, ,$$@)).saige.samples | $$(dir $$@)
	if [[ $(call check_model_matrix,$(subst .success,,$(word 2,$^)),$(MINIMUM_VALID_SUBJECT_COUNT),$(MINIMUM_VALID_CASE_COUNT)) ]] ; then \
	$(call qsub_handler_long,$(subst .success,,$@),Rscript $(SAIGE_ROUND_2_SCRIPT) $(word 3,$^) $(word 4,$^) $(subst .success,.rda,$<) $(subst .success,.varianceRatio.txt,$<) $(subst .success,.varianceRatio.txt_relatednessCutoff_$(SAIGE_ROUND_1_RELATEDNESS_CUTOFF)_1000_randomMarkersUsed.sparseSigma.mtx,$<) $(word 5,$^) $(subst .success,,$@) chr$(lastword $(subst .chr, ,$(subst .saige.success,,$@)))) ; \
	else \
	touch $@ ; \
	fi

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.samples
##    input:  {BGEN-INPUT}/{CHIP}/{ANCESTRY}/chr22-filtered-noNAs.sample
## Notes: final subject list for actual imputed data, originally required to prune extra subjects from chip or imputed data
%.saige.samples: $$(IMPUTED_DIR)/$$(call extract_chip,$$(subst .saige.samples,,$$@),/)/$$(call extract_ancestry,$$@)/chr22-filtered-noNAs.sample | $$(dir $$@)
	awk 'NR > 2 {print $$1}' $< > $@

## utility function to just grab comma-delimited covariates from a model matrix
define get_covariates_from_model_matrix
$(shell awk 'NR == 1' $(1) | cut -f 1-3 --complement | sed 's/ /,/g; s/\t/,/g')
endef

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.round1.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38-resorted-nochr0.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.phenotype_selected
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.model_matrix.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
%.saige.round1.success: %.saige-chip.GRCh38-resorted-nochr0.bed.success %.saige.phenotype_selected %.saige.model_matrix.success | $$(dir $$@)
	if [[ $(call check_model_matrix,$(subst .success,,$(lastword $^)),$(MINIMUM_VALID_SUBJECT_COUNT),$(MINIMUM_VALID_CASE_COUNT)) ]] ; then \
	rm -f $@.varianceRatio.txt $@.rda ; \
	$(call qsub_handler_long,$(subst .success,,$@),Rscript $(SAIGE_ROUND_1_SCRIPT) $(subst .bed.success,,$<) $(subst .success,,$(lastword $^)) $(call get_tracked_parameter,$(word 2,$^)) $(if $(call get_covariates_from_model_matrix,$(subst .success,,$(word 3,$^))),$(call get_covariates_from_model_matrix,$(subst .success,,$(word 3,$^))),NA) $(SAIGE_ROUND_1_RELATEDNESS_CUTOFF) $(subst .success,,$@)) ; \
	else \
	touch $@ ; \
	fi


## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.model_matrix.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.phenotype_dataset
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.phenotype_selected
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.covariates_selected
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.sex-specific
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.samples
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: build a model matrix containing phenotype and covariate data for all relevant subjects. for truly esoteric reasons
## this is separately submitted to the cluster. Direct config file dependency has been removed to prevent
## repeated reruns due to version control, unrelated database updates, and other trivial issues.
%.saige.model_matrix.success: %.saige.phenotype_dataset %.saige.phenotype_selected %.saige.covariates_selected %.saige.sex-specific %.saige.samples | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),Rscript $(SHARED_SOURCE)/construct_model_matrix.R $(PHENOTYPE_FILENAME) $(lastword $^) $(word 2,$(subst /, ,$(subst $(RESULTS_DIR),,$@))) $(lastword $(subst ., ,$(subst .saige.model_matrix.success,,$@))) $(call get_tracked_parameter,$(word 2,$^)) $(call get_tracked_parameter,$(word 3,$^)) $(subst .success,,$@) none $(call get_tracked_parameter,$(word 4,$^)))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/
## Notes: build the output directory tree if needed.
$(sort $(dir $(ANALYSIS_RESULTS_SAIGE))):
	mkdir -p $@


## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38-resorted-nochr0.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38-resorted.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip-GRCh38-resorted-chr0.exclude
## Notes: remove "0" chromosome annotations for compatibility with SAIGE
%.saige-chip.GRCh38-resorted-nochr0.bed.success: %.saige-chip.GRCh38-resorted.bed.success %.saige-chip.GRCh38-resorted.chr0.exclude | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --exclude $(word 2,$^) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38-resorted.chr0.exclude
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38-resorted.bed.success (really bim)
## Notes: get a plink-format exclude file for variants with unlocalized chromosome
%.saige-chip.GRCh38-resorted.chr0.exclude: %.saige-chip.GRCh38-resorted.bed.success | $$(dir $$@)
	awk '$$1 == 0 {print $$2}' $(subst .bed.success,.bim,$<) > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38-resorted.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38.bed
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip-GRCh38.bim
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38.fam
## Notes: liftover likely breaks order of variants in the genome; quickest solution is just to reload and rewrite everything with plink.
%.saige-chip.GRCh38-resorted.bed.success: %.saige-chip.GRCh38.bed %.saige-chip.GRCh38.bim %.saige-chip.GRCh38.fam | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bed $< --bim $(word 2,$^) --fam $(word 3,$^) --allow-extra-chr 0 --make-bed --out $(subst .bed.success,,$@))



## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38.bed
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.lift-failures-excluded.bed.success
## Notes: this was a late addition to the pipeline, as it was originally tested on chip data in hg19 but then deployed on
## imputed data in GRCh38. so it's just a hack liftover intermediate step.
%.saige-chip.GRCh38.bed: %.saige-chip.lift-failures-excluded.bed.success | $$(dir $$@)
	cp $(subst .success,,$<) $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38.bim
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.lift-failures-excluded.bed.success (really bim)
## Notes: this was a late addition to the pipeline, as it was originally tested on chip data in hg19 but then deployed on
## imputed data in GRCh38. so it's just a hack liftover intermediate step.
%.saige-chip.GRCh38.bim: %.saige-chip.lift-failures-excluded.bed.success %.saige-chip.liftover-output | $$(dir $$@)
	paste $(word 2,$^) $(subst .bed.success,.bim,$<) | sed 's/^chr//' | awk '{print $$1"\t"$$5"\t"$$6"\t"$$2+1"\t"$$8"\t"$$9}' > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.GRCh38.fam
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.lift-failures-excluded.bed.success (really fam)
## Notes: this was a late addition to the pipeline, as it was originally tested on chip data in hg19 but then deployed on
## imputed data in GRCh38. so it's just a hack liftover intermediate step.
%.saige-chip.GRCh38.fam: %.saige-chip.lift-failures-excluded.bed.success | $$(dir $$@)
	cp $(subst .bed.success,.fam,$<) $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.lift-failures-excluded.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.bed.success
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.liftover.exclude
## Notes: first step to updating plink file with GRCh38 lifted positions: remove variants that failed lift, in order
%.saige-chip.lift-failures-excluded.bed.success: %.saige-chip.bed.success %.saige-chip.liftover.exclude | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed.success,,$<) --exclude $(word 2,$^) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.liftover.exclude
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.liftover-output (really liftover-failure)
## Notes: convert failed lifts into a plink-format exclude file
%.saige-chip.liftover.exclude: %.saige-chip.liftover-output | $$(dir $$@)
	awk '! /^#/ {print $$1":"$$2+1}' $(subst liftover-output,liftover-failure,$<) | sed 's/^chr//' > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.liftover-output
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.liftover-input
## Notes: run liftover, chips are in hg19 and imputed data are in GRCh38
%.saige-chip.liftover-output: %.saige-chip.liftover-input | $$(dir $$@)
	$(LIFTOVER_EXECUTABLE) $< $(LIFTOVER_19_TO_38) $@ $(subst liftover-output,liftover-failure,$@)

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.liftover-input
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.bed.success
## Notes:
%.saige-chip.liftover-input: %.saige-chip.bed.success | $$(dir $$@)
	awk '{print "chr"$$1"\t"$$4-1"\t"$$4}' $(subst .bed.success,.bim,$<) > $@

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige-chip.bed.success
##    input:  {CLEANED_CHIPS_BY_ANCESTRY}/{ANCESTRY}/{CHIP}.nohet.autosomes.bed
##    input:  results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.samples.plink-format
##    input:  {CLEANED_CHIPS_BY_ANCESTRY}/{ANCESTRY}/{CHIP}.step2.pruning.prune.in
##    input:  {CLEANED_CHIPS_BY_ANCESTRY}/{ANCESTRY}/{CHIP}.step3.pruning.prune.out
## Notes: gets an ancestry-specific LD-pruned (more or less) dataset for SAIGE heritability estimation.
%.saige-chip.bed.success: $(GENOTYPE_DIR)/$$(call extract_ancestry,$$@)/$$(firstword $$(subst /, ,$$(call extract_chip,$$(subst .saige-chip.bed.success,,$$@),/))).nohet.autosomes.bed %.saige.samples.plink-format $(GENOTYPE_DIR)/$$(call extract_ancestry,$$@)/$$(firstword $$(subst /, ,$$(call extract_chip,$$(subst .saige-chip.bed.success,,$$@),/))).step2.pruning.prune.in $(GENOTYPE_DIR)/$$(call extract_ancestry,$$@)/$$(firstword $$(subst /, ,$$(call extract_chip,$$(subst .saige-chip.bed.success,,$$@),/))).step3.pruning.prune.out | $$(dir $$@)
	$(call qsub_handler,$(subst .success,,$@),$(PLINK19) --bfile $(subst .bed,,$<) --keep $(word 2,$^) --extract $(word 3,$^) --exclude $(word 4,$^) --make-bed --out $(subst .bed.success,,$@))

## patterns:
##    output: results/{PHENOTYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.samples.plink-format
##    input:  results/{PHENTOYPE}/{ANCESTRY}/{METHOD}/{PHENOTYPE}.{CHIP}.saige.samples
## Notes: take single column subject ID list and duplicate it into two columns, for plink --keep convention.
%.saige.samples.plink-format: %.saige.samples | $$(dir $$@)
	awk '{print $$1"\t"$$1}' $< > $@

## phony target for removing intermediate files. Somewhat dangerous but extremely helpful for disk usage
secondary-clean:
	for analysis in $(ANALYSIS_RESULTS_SAIGE) ; \
	do \
	touch $$analysis.finalized ; \
	done
	for dir in $(dir $(ANALYSIS_RESULTS_SAIGE)) ; \
	do \
	rm -f $$dir/*output ; \
	rm -f $$dir/*error ; \
	rm -f $$dir/*saige.txt ; \
	rm -f $$dir/*bed ; \
	rm -f $$dir/*bim ; \
	rm -f $$dir/*fam ; \
	rm -f $$dir/*plot_ready ; \
	rm -f $$dir/*tsv ; \
	done
